// Hexen grammar with unified declaration syntax
// Philosophy: One declaration pattern for all - name : type = value

program: (function | statement)+

function: FUNC IDENTIFIER "(" parameter_list? ")" ":" type "=" block

parameter_list: parameter ("," parameter)*

parameter: IDENTIFIER ":" type
         | MUT IDENTIFIER ":" type

block: "{" statement* "}"

statement: var_declaration
         | return_stmt
         | assign_stmt
         | assignment_stmt
         | conditional_stmt
         | for_in_loop
         | while_loop
         | break_stmt
         | continue_stmt
         | labeled_stmt
         | block
         | function_call_stmt

function_call_stmt: function_call

var_declaration: val_declaration
               | mut_declaration

val_declaration: VAL IDENTIFIER ":" type "=" (expression | "undef")
               | VAL IDENTIFIER "=" expression

mut_declaration: MUT IDENTIFIER ":" type "=" (expression | "undef")

return_stmt: "return" expression?

assign_stmt: "->" expression

assignment_stmt: IDENTIFIER "=" expression

conditional_stmt: "if" expression block else_clause*

else_clause: "else" "if" expression block
           | "else" block

// Loop System
for_in_loop: FOR IDENTIFIER (":" type)? IN expression block

while_loop: WHILE expression block

break_stmt: BREAK LABEL?

continue_stmt: CONTINUE LABEL?

labeled_stmt: LABEL statement

expression: logical_or

logical_or: logical_and (OR_OP logical_and)*
logical_and: equality (AND_OP equality)*
equality: relational (EQ_OP relational)*
relational: additive (REL_OP additive)*
          | range_bounded
          | range_from
          | range_to
          | range_full
additive: multiplicative (ADD_OP multiplicative)*
multiplicative: unary (MUL_OP unary)*
unary: UNARY_OP unary
     | conversion
conversion: postfix (CONVERSION_OP type)?
postfix: primary (array_suffix | property_access)*
primary: NUMBER | STRING | BOOLEAN | function_call | IDENTIFIER | block | conditional_stmt | labeled_for_expr | for_in_loop | labeled_while_expr | while_loop | array_literal | "(" expression ")"

// Labeled loop expressions (for use in expression contexts)
labeled_for_expr: LABEL for_in_loop
labeled_while_expr: LABEL while_loop

// Range expressions (between relational and additive precedence)
range_bounded: additive RANGE_EXCLUSIVE additive (":" additive)?
             | additive RANGE_INCLUSIVE additive (":" additive)?

range_from: additive RANGE_EXCLUSIVE (":" additive)?

range_to: RANGE_EXCLUSIVE additive (":" additive)?
        | RANGE_INCLUSIVE additive (":" additive)?

range_full: RANGE_EXCLUSIVE (":" additive)?
          | RANGE_INCLUSIVE (":" additive)?  // Invalid: parsed but rejected semantically

array_suffix: array_access
array_access: "[" expression "]"
property_access: "." IDENTIFIER
array_literal: "[" [expression ("," expression)*] "]"

function_call: IDENTIFIER "(" argument_list? ")"

argument_list: expression ("," expression)*

OR_OP: "||"
AND_OP: "&&"
EQ_OP: "==" | "!="
REL_OP: "<" | ">" | "<=" | ">="
ADD_OP: "+" | "-"
MUL_OP: "*" | "/" | "\\" | "%"
UNARY_OP: "-" | "!"
RANGE_EXCLUSIVE: ".."
RANGE_INCLUSIVE: "..="

type: primitive_type
    | array_type
    | range_type

range_type: "range" "[" type "]"

primitive_type: TYPE_I32
              | TYPE_I64
              | TYPE_F32
              | TYPE_F64
              | TYPE_USIZE
              | TYPE_STRING
              | TYPE_BOOL
              | TYPE_VOID

array_type: array_dimension+ primitive_type

array_dimension: "[" (INTEGER | "_") "]"

TYPE_I32: "i32"
TYPE_I64: "i64"
TYPE_F32: "f32"
TYPE_F64: "f64"
TYPE_USIZE: "usize"
TYPE_STRING: "string"
TYPE_BOOL: "bool"
TYPE_VOID: "void"

VAL: /val\b/
MUT: /mut\b/
FUNC: /func\b/
FOR: /for\b/
WHILE: /while\b/
BREAK: /break\b/
CONTINUE: /continue\b/
IN: /in\b/

// Terminals
LABEL: /'[a-zA-Z_][a-zA-Z0-9_]*/
IDENTIFIER: /(?!val\b|mut\b|func\b|return\b|true\b|false\b|if\b|else\b|for\b|while\b|break\b|continue\b|in\b)[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: SIGN? (SCIENTIFIC | HEXADECIMAL | BINARY | DECIMAL | INTEGER)
STRING: /\"[^\"]*\"/
BOOLEAN: "true" | "false"

// Enhanced number format definitions
SCIENTIFIC: (DIGITS "." DIGITS | DIGITS) ("e"|"E") SIGN? DIGITS
HEXADECIMAL: "0" ("x"|"X") /[0-9a-fA-F]+/
BINARY: "0" ("b"|"B") /[01]+/
DECIMAL: DIGITS "." DIGITS
INTEGER: DIGITS

DIGITS: /[0-9]+/
SIGN: /[+-]/

// Conversion operator (tight binding, high priority)
CONVERSION_OP.10: /:(?=i32|i64|f32|f64|usize|string|bool|void|\[|range)/

// Ignore whitespace and comments
%import common.WS
COMMENT: /\/\/[^\r\n]*/
%ignore WS
%ignore COMMENT 