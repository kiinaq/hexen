// Literal Ergonomics Example
// This demonstrates how Hexen handles literals without suffixes

func main() : i32 = {
    // Same literal "42" adapts to different contexts
    val default_int = 42          // comptime_int -> i32 (default)
    val as_i64 : i64 = 42         // comptime_int -> i64 (context determines)
    val as_f32 : f32 = 42         // comptime_int -> f32 (context determines)
    
    // Same literal "3.14" adapts to different float types
    val default_float = 3.14      // comptime_float -> f64 (default)
    val as_f32_float : f32 = 3.14 // comptime_float -> f32 (context determines)
    
    // Comptime types are preserved through expressions
    val computation = 42 + 100 * 3.14  // Still comptime_float!
    val result_f32 : f32 = computation  // Same expression -> f32
    val result_f64 : f64 = computation  // Same expression -> f64
    
    // But mixed concrete types require explicit conversion
    val concrete_i32 : i32 = 10
    val concrete_f64 : f64 = 3.14
    // val mixed = concrete_i32 + concrete_f64     // Error: explicit conversion required
    val explicit : f64 = concrete_i32:f64 + concrete_f64  // Conversion cost visible
    
    return 0
}