// Multidimensional array examples for Hexen language
// Demonstrates complex array types and nested access patterns

func matrix_examples() : void = {
    // 2D arrays (matrices) with fixed dimensions
    val matrix_2x3 : [2][3]i32 = [
        [1, 2, 3],
        [4, 5, 6]
    ]
    
    // 3x3 matrix with floating point values
    val identity_3x3 : [3][3]f64 = [
        [1.0, 0.0, 0.0],
        [0.0, 1.0, 0.0],
        [0.0, 0.0, 1.0]
    ]
    
    // Mixed fixed and inferred dimensions
    val mixed_matrix : [2][_]i32 = [
        [10, 20, 30, 40],
        [50, 60, 70, 80]
    ]
    
    // Access 2D array elements
    val top_left = matrix_2x3[0][0]        // First row, first column (1)
    val bottom_right = matrix_2x3[1][2]    // Second row, third column (6)
    val center = identity_3x3[1][1]        // Center element (1.0)
    
    return
}

func cube_examples() : void = {
    // 3D arrays (cubes)
    val cube_2x2x2 : [2][2][2]i32 = [
        [
            [1, 2],
            [3, 4]
        ],
        [
            [5, 6], 
            [7, 8]
        ]
    ]
    
    // Access 3D array elements
    val corner1 = cube_2x2x2[0][0][0]      // (1)
    val corner2 = cube_2x2x2[1][1][1]      // (8)
    val middle = cube_2x2x2[0][1][0]       // (3)
    
    return
}

func hypercube_examples() : void = {
    // 4D arrays (hypercubes) - all inferred dimensions
    val hypercube : [_][_][_][_]f32 = [
        [
            [
                [1.0, 2.0], [3.0, 4.0]
            ],
            [
                [5.0, 6.0], [7.0, 8.0]
            ]
        ]
    ]
    
    // Complex 4D access
    val hypervalue = hypercube[0][0][1][0]  // (3.0)
    
    return
}

func chained_access_examples() : void = {
    // Complex chained array access with expressions
    val data : [3][4][2]i32 = [
        [
            [10, 11], [12, 13], [14, 15], [16, 17]
        ],
        [
            [20, 21], [22, 23], [24, 25], [26, 27]  
        ],
        [
            [30, 31], [32, 33], [34, 35], [36, 37]
        ]
    ]
    
    // Access using variables as indices
    val i = 1
    val j = 2  
    val k = 0
    val dynamic_value = data[i][j][k]       // data[1][2][0] = 24
    
    // Access using expressions as indices
    val computed = data[0 + 1][3 - 1][1]    // data[1][2][1] = 25
    val complex = data[i * 2][j + 1][k + 1] // data[2][3][1] = 37
    
    return
}

func mixed_type_multidim() : void = {
    // Different element types in multidimensional arrays
    val string_matrix : [2][3]string = [
        ["red", "green", "blue"],
        ["cyan", "magenta", "yellow"]
    ]
    
    val bool_cube : [2][2][2]bool = [
        [
            [true, false],
            [false, true]
        ],
        [
            [false, true],
            [true, false]
        ]
    ]
    
    // Access mixed type arrays
    val color = string_matrix[0][1]         // "green"
    val flag = bool_cube[1][0][1]           // true
    
    return
}

func array_of_arrays_vs_multidim() : void = {
    // Note: These are equivalent in Hexen
    val multidim : [3][4]i32 = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9, 10, 11, 12]
    ]
    
    // Both access patterns work the same way
    val element1 = multidim[1][2]           // 7
    
    return
}

func main() : void = {
    matrix_examples()
    cube_examples()
    hypercube_examples()
    chained_access_examples()
    mixed_type_multidim()
    array_of_arrays_vs_multidim()
    return
}