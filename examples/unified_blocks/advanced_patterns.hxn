// Advanced Pattern Examples: Real-World Unified Block System Usage
//
// This file demonstrates sophisticated patterns that combine compile-time preservation
// with runtime classification for realistic development scenarios.

// =============================================================================
// HELPER FUNCTIONS FOR ADVANCED EXAMPLES
// =============================================================================

func get_configuration_value(key: string) : i32 = { return 42 }
func load_user_preferences() : f64 = { return 1.5 }
func calculate_hash(input: string) : i64 = { return 12345 }
func fetch_from_database(id: i64) : f64 = { return 99.99 }
func log_performance_metric(name: string, value: f64) : void = { return }
func is_development_mode() : bool = { return true }
func get_memory_usage() : f64 = { return 256.0 }

// =============================================================================
// PATTERN 1: CONFIGURATION SYSTEM WITH COMPILE-TIME AND RUNTIME VALUES
// =============================================================================

func demonstrate_configuration_patterns() : void = {
    // Compile-time configuration values - preserved for flexibility
    val default_settings = {
        val timeout_seconds = 30            // comptime_int
        val retry_count = 3                 // comptime_int
        val buffer_size = 1024              // comptime_int
        assign timeout_seconds * retry_count * buffer_size  // All comptime
    }
    
    // Runtime configuration with user preferences
    val user_settings : f64 = {            // Context REQUIRED! (function calls)
        val user_multiplier = load_user_preferences()  // Function call → runtime
        val base_config = 100               // comptime_int
        assign base_config * user_multiplier  // comptime + concrete → needs context
    }
    
    // Hybrid: compile-time base with runtime override
    val final_settings : i32 = {           // Context REQUIRED! (function calls)
        val compile_time_default = default_settings:i32  // Use preserved comptime value
        val runtime_override = get_configuration_value("buffer_size")
        val result = if runtime_override > 0 {
            assign runtime_override          // Use runtime value
        } else {
            assign compile_time_default      // Fall back to compile-time
        }
        assign result
    }
    
    return
}

// =============================================================================
// PATTERN 2: PERFORMANCE MONITORING WITH MIXED EVALUATION
// =============================================================================

func demonstrate_performance_monitoring() : void = {
    // Compile-time performance thresholds - reusable across contexts
    val performance_thresholds = {
        val cpu_warning = 80                // comptime_int (percentage)
        val memory_critical = 90            // comptime_int (percentage)
        val response_time_limit = 500       // comptime_int (milliseconds)
        assign cpu_warning + memory_critical + response_time_limit  // Comptime sum
    }
    
    // Runtime performance monitoring
    val current_metrics : f64 = {          // Context REQUIRED! (function calls)
        val memory_usage = get_memory_usage()  // Function call → runtime
        val warning_threshold = performance_thresholds:f64  // Use comptime value
        
        if memory_usage > warning_threshold {
            log_performance_metric("high_memory", memory_usage)
            return -1.0                     // Early exit: performance issue
        }
        
        assign memory_usage
    }
    
    // Use compile-time thresholds in different numeric contexts
    val cpu_threshold_i32 : i32 = performance_thresholds   // For integer comparison
    val memory_threshold_f64 : f64 = performance_thresholds  // For float comparison
    val timeout_threshold_i64 : i64 = performance_thresholds  // For timestamp comparison
    
    return
}

// =============================================================================
// PATTERN 3: CACHING SYSTEM WITH COMPILE-TIME CONSTANTS AND RUNTIME LOGIC
// =============================================================================

func demonstrate_advanced_caching(cache_key: string) : f64 = {
    // Compile-time cache configuration - preserved for multiple uses
    val cache_config = {
        val max_entries = 1000              // comptime_int
        val ttl_seconds = 300               // comptime_int (5 minutes)
        val hash_modulo = 997               // comptime_int (prime for good distribution)
        assign max_entries + ttl_seconds + hash_modulo  // Configuration sum
    }
    
    // Runtime cache logic with function calls and conditionals
    val cache_result : f64 = {             // Context REQUIRED! (function calls + conditionals)
        val key_hash = calculate_hash(cache_key)  // Function call → runtime
        val modulo_value = cache_config:i64  // Use compile-time config as i64
        val cache_slot = key_hash % modulo_value
        
        // Simulate cache lookup with development mode check
        val is_dev = is_development_mode()  // Function call
        if is_dev {
            // In development, always fetch fresh data
            assign fetch_from_database(cache_slot)
        } else {
            // In production, use more complex caching logic
            val ttl_limit = cache_config:f64  // Use compile-time config as f64
            val data = fetch_from_database(cache_slot)
            assign data * ttl_limit          // Apply TTL-based weighting
        }
    }
    
    return cache_result
}

// =============================================================================
// PATTERN 4: MATHEMATICAL LIBRARY WITH PRECISION ADAPTATION
// =============================================================================

func demonstrate_precision_adaptation() : void = {
    // Mathematical constants preserved for precision adaptation
    val mathematical_constants = {
        val pi_numerator = 355              // comptime_int (better approximation)
        val pi_denominator = 113            // comptime_int
        val e_approximation = 2718          // comptime_int (scaled by 1000)
        val golden_ratio_num = 1618         // comptime_int (scaled by 1000)
        assign pi_numerator + pi_denominator + e_approximation + golden_ratio_num
    }
    
    // Use constants in different precision contexts
    val single_precision : f32 = mathematical_constants    // For real-time graphics
    val double_precision : f64 = mathematical_constants    // For scientific computation
    val integer_approximation : i32 = mathematical_constants  // For discrete algorithms
    val long_precision : i64 = mathematical_constants      // For financial calculations
    
    // Runtime computation with precision selection
    val adaptive_precision : f64 = {       // Context REQUIRED! (function calls + conditionals)
        val precision_mode = get_configuration_value("precision")
        val base_constant = mathematical_constants:f64
        
        val result = if precision_mode == 1 {
            assign base_constant * 0.001    // Scale down for single precision
        } else if precision_mode == 2 {
            assign base_constant * 0.000001 // Scale down for double precision
        } else {
            assign base_constant            // Use as-is for maximum precision
        }
        
        assign result
    }
    
    return
}

// =============================================================================
// PATTERN 5: GAME ENGINE STYLE RESOURCE MANAGEMENT
// =============================================================================

func demonstrate_resource_management() : void = {
    // Compile-time resource limits - adaptable to different systems
    val resource_limits = {
        val max_textures = 512              // comptime_int
        val max_vertices = 65536            // comptime_int
        val max_audio_channels = 32         // comptime_int
        assign max_textures + max_vertices + max_audio_channels  // Total resources
    }
    
    // Runtime resource allocation with dynamic scaling
    val allocated_resources : i32 = {      // Context REQUIRED! (function calls + conditionals)
        val available_memory = get_memory_usage()  // Function call → runtime
        val base_limit = resource_limits:i32       // Use compile-time limit
        
        // Scale resources based on available memory
        val scaling_factor = if available_memory > 1000.0 {
            assign 1.0                      // High memory: full resources
        } else if available_memory > 500.0 {
            assign 0.75                     // Medium memory: 75% resources
        } else {
            assign 0.5                      // Low memory: 50% resources
        }
        
        assign (base_limit:f64 * scaling_factor):i32  // Explicit conversions
    }
    
    // Use resource limits in different system contexts
    val texture_limit_i32 : i32 = resource_limits      // For array allocation
    val vertex_limit_i64 : i64 = resource_limits       // For buffer sizing
    val audio_limit_f32 : f32 = resource_limits        // For audio calculations
    
    return
}

// =============================================================================
// PATTERN 6: FINANCIAL CALCULATIONS WITH PRECISION GUARANTEES
// =============================================================================

func demonstrate_financial_calculations(principal: f64, rate_percent: f64, years: i32) : f64 = {
    // Compile-time financial constants - preserved for different calculations
    val financial_constants = {
        val days_per_year = 365             // comptime_int
        val months_per_year = 12            // comptime_int
        val basis_points = 10000            // comptime_int (for percentage conversion)
        val precision_multiplier = 1000000  // comptime_int (for micro-precision)
        assign days_per_year * months_per_year * basis_points  // Combined constant
    }
    
    // Runtime compound interest calculation
    val compound_interest : f64 = {        // Context REQUIRED! (mixed types + conditionals)
        val annual_rate = rate_percent / 100.0  // Convert percentage to decimal
        val compounding_periods = years:f64 * 12.0  // Monthly compounding
        
        // Use compile-time constants in calculation
        val precision_factor = financial_constants:f64 / 1000000.0  // Normalize precision
        
        // Calculate compound interest with precision adjustment
        val base_calculation = principal * annual_rate * compounding_periods
        val precision_adjusted = base_calculation * precision_factor
        
        // Apply minimum return guarantee
        val minimum_return = principal * 0.01  // 1% minimum
        val result = if precision_adjusted < minimum_return {
            assign minimum_return            // Guarantee minimum return
        } else {
            assign precision_adjusted        // Use calculated return
        }
        
        assign result
    }
    
    return compound_interest
}

// =============================================================================
// PATTERN 7: ALGORITHMIC PARAMETERS WITH RUNTIME ADAPTATION
// =============================================================================

func demonstrate_algorithmic_adaptation() : void = {
    // Compile-time algorithm parameters - reusable across implementations
    val algorithm_params = {
        val max_iterations = 1000           // comptime_int
        val convergence_threshold = 100     // comptime_int (scaled)
        val learning_rate_scaled = 1        // comptime_int (0.001 * 1000)
        val momentum_factor = 90            // comptime_int (0.9 * 100)
        assign max_iterations + convergence_threshold + learning_rate_scaled + momentum_factor
    }
    
    // Runtime algorithm execution with parameter adaptation
    val algorithm_result : f64 = {         // Context REQUIRED! (function calls + conditionals)
        val dataset_size = get_configuration_value("dataset_size")
        val base_params = algorithm_params:f64
        
        // Adapt parameters based on dataset size
        val adapted_iterations = if dataset_size > 10000 {
            assign base_params * 2.0         // Large dataset: more iterations
        } else if dataset_size > 1000 {
            assign base_params * 1.5         // Medium dataset: moderate iterations
        } else {
            assign base_params               // Small dataset: base iterations
        }
        
        // Simulate algorithm execution
        val memory_constraint = get_memory_usage()
        val final_result = if memory_constraint > 500.0 {
            assign adapted_iterations * 0.8  // Memory constrained: reduce complexity
        } else {
            assign adapted_iterations        // Full complexity
        }
        
        assign final_result
    }
    
    // Use algorithm parameters in different contexts
    val iterations_i32 : i32 = algorithm_params    // For loop counters
    val threshold_f32 : f32 = algorithm_params     // For float comparisons
    val rate_f64 : f64 = algorithm_params          // For high-precision calculations
    
    return
}

// =============================================================================
// MAIN DEMONSTRATION FUNCTION
// =============================================================================

func main() : void = {
    demonstrate_configuration_patterns()
    demonstrate_performance_monitoring()
    demonstrate_resource_management()
    demonstrate_algorithmic_adaptation()
    
    // Test complex patterns with realistic parameters
    val cache_value = demonstrate_advanced_caching("user_profile_123")
    val financial_result = demonstrate_financial_calculations(10000.0, 5.5, 10)
    
    return
}