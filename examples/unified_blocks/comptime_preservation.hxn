// Advanced Pattern Examples: Compile-Time Type Preservation
//
// This file demonstrates the "one computation, multiple uses" pattern enabled by 
// compile-time evaluable blocks in the enhanced unified block system.

// =============================================================================
// PATTERN 1: FLEXIBLE MATHEMATICAL COMPUTATIONS
// =============================================================================

func demonstrate_comptime_preservation() : void = {
    // ✨ Compile-time evaluable block preserves comptime types
    val flexible_computation = {
        val base = 42              // comptime_int
        val multiplier = 100       // comptime_int  
        val factor = 3.14          // comptime_float
        val result = base * multiplier + factor  // All comptime operations → comptime_float
        assign result              // Block result: comptime_float (preserved!)
    }
    
    // Same computation, multiple contexts - maximum flexibility!
    val as_f32 : f32 = flexible_computation    // comptime_float → f32 (implicit)
    val as_f64 : f64 = flexible_computation    // SAME source → f64 (different context!)
    val as_i32 : i32 = flexible_computation:i32  // SAME source → i32 (explicit conversion)
    
    return
}

// =============================================================================
// PATTERN 2: CONFIGURATION VALUES WITH CONTEXT ADAPTATION
// =============================================================================

func demonstrate_adaptive_configuration() : void = {
    // Configuration block that adapts to usage context
    val screen_dimensions = {
        val width = 1920          // comptime_int
        val height = 1080         // comptime_int
        assign width * height     // comptime_int * comptime_int → comptime_int
    }
    
    // Same configuration used in different numeric contexts
    val pixel_count_i32 : i32 = screen_dimensions       // For array indexing
    val pixel_count_i64 : i64 = screen_dimensions       // For large calculations
    val pixel_count_f32 : f32 = screen_dimensions       // For graphics calculations
    val pixel_count_f64 : f64 = screen_dimensions       // For high-precision math
    
    return
}

// =============================================================================
// PATTERN 3: COMPLEX MATHEMATICAL FORMULAS
// =============================================================================

func demonstrate_mathematical_flexibility() : void = {
    // Complex mathematical formula preserved as comptime
    val physics_calculation = {
        val gravity = 9.81        // comptime_float
        val mass = 100            // comptime_int
        val time = 5.0            // comptime_float
        val force = mass * gravity * time  // All comptime → comptime_float
        assign force              // Preserved for flexible usage
    }
    
    // Same physics calculation used in different precision contexts
    val force_single : f32 = physics_calculation        // Single precision for real-time
    val force_double : f64 = physics_calculation        // Double precision for simulation
    val force_integer : i32 = physics_calculation:i32   // Integer for discrete calculations
    
    return
}

// =============================================================================
// PATTERN 4: NESTED COMPTIME BLOCKS
// =============================================================================

func demonstrate_nested_comptime_blocks() : void = {
    // Nested blocks all preserve comptime types
    val outer_computation = {
        val inner_calc = {
            val a = 42            // comptime_int
            val b = 3.14          // comptime_float
            assign a + b          // comptime_int + comptime_float → comptime_float
        }
        
        val scaling_factor = 2.5  // comptime_float
        assign inner_calc * scaling_factor  // comptime_float * comptime_float → comptime_float
    }
    
    // Outer result preserves flexibility for multiple uses
    val graphics_precision : f32 = outer_computation
    val physics_precision : f64 = outer_computation
    val index_value : i32 = outer_computation:i32
    
    return
}

// =============================================================================
// PATTERN 5: COMPTIME CONSTANTS WITH DERIVED VALUES
// =============================================================================

func demonstrate_comptime_constants() : void = {
    // Base constants
    val pi_approximation = {
        val numerator = 22        // comptime_int
        val denominator = 7       // comptime_int
        assign numerator / denominator  // comptime_int / comptime_int → comptime_float
    }
    
    // Derived constants from base
    val circle_area_formula = {
        val radius = 5            // comptime_int
        assign pi_approximation * radius * radius  // All comptime → comptime_float
    }
    
    // Use derived constants in different contexts
    val area_f32 : f32 = circle_area_formula     // For graphics
    val area_f64 : f64 = circle_area_formula     // For scientific computation
    val area_rounded : i32 = circle_area_formula:i32  // For discrete representation
    
    return
}

// =============================================================================
// PATTERN 6: COMPTIME OPTIMIZATION PATTERNS
// =============================================================================

func demonstrate_comptime_optimization() : void = {
    // Expensive computations done at compile-time, preserved for reuse
    val expensive_constant = {
        val base = 42             // comptime_int
        val power = 3             // comptime_int
        val result = base * base * base  // Computed once, used many times
        assign result             // Preserved as comptime_int
    }
    
    // Multiple uses of the pre-computed value in different contexts
    val lookup_table_size : i32 = expensive_constant    // Array size
    val buffer_capacity : i64 = expensive_constant      // Memory allocation
    val threshold_value : f64 = expensive_constant      // Numerical threshold
    
    return
}

// =============================================================================
// MAIN DEMONSTRATION FUNCTION
// =============================================================================

func main() : void = {
    demonstrate_comptime_preservation()
    demonstrate_adaptive_configuration()
    demonstrate_mathematical_flexibility()
    demonstrate_nested_comptime_blocks()
    demonstrate_comptime_constants()
    demonstrate_comptime_optimization()
    return
}