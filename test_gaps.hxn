func test_gaps() : void = {
    // ============ GAP 1: Comptime Type Preservation ============
    // Documentation promises: val preserves comptime types for flexible adaptation
    
    // Test 1A: Basic comptime preservation
    val flexible_int = 42                    // Should stay comptime_int
    val flexible_math = 42 + 100 * 3        // Should stay comptime_int
    val flexible_float = 10 / 3             // Should stay comptime_float
    
    // Test 1B: Same source, different targets (flexibility test)
    val as_i32 : i32 = flexible_int         // comptime_int → i32
    val as_i64 : i64 = flexible_int         // SAME source → i64
    val as_f64 : f64 = flexible_int         // SAME source → f64
    
    // Test 1C: Complex expressions staying comptime
    val complex_calc = (42 + 100) * 3.14 + (50 / 7) - (25 \ 4)  // Should stay comptime_float
    val precision_f64 : f64 = complex_calc  // Should adapt to f64
    val precision_f32 : f32 = complex_calc  // SAME source → f32
    
    // ============ GAP 2: mut vs val Comptime Handling ============
    // Documentation promises: mut cannot preserve comptime types
    
    // Test 2A: val preserves comptime (should work)
    val preserved_val = 42 + 100           // Should preserve comptime_int
    val val_as_i32 : i32 = preserved_val   // Should adapt flexibly
    val val_as_i64 : i64 = preserved_val   // SAME source, different target
    
    // Test 2B: mut forces immediate resolution (should lose flexibility)
    mut concrete_mut : i32 = 42 + 100      // Should immediately resolve to i32
    // val mut_as_i64 : i64 = concrete_mut // Should ERROR: i32 cannot adapt to i64
    val mut_converted : i64 = concrete_mut:i64  // Should require explicit conversion
    
    // ============ GAP 3: Explicit Conversion Syntax ============
    // Documentation promises: value:type syntax for all concrete conversions
    
    // Test 3A: Basic explicit conversions
    val int_val : i32 = 42
    val float_val : f64 = 3.14
    val converted_i64 : i64 = int_val:i64    // Should work: i32 → i64
    val converted_f32 : f32 = float_val:f32  // Should work: f64 → f32
    
    // Test 3B: Comptime explicit conversions (when unsafe)
    val explicit_truncate : i32 = 3.14:i32  // Should work: comptime_float → i32
    
    // ============ GAP 4: Mixed Concrete Type Restrictions ============
    // Documentation promises: mixed concrete types require explicit conversions
    
    // Test 4A: Same concrete types (should work seamlessly)
    val a : i32 = 10
    val b : i32 = 20
    val same_types : i32 = a + b             // i32 + i32 → i32 (should work)
    
    // Test 4B: Mixed concrete types (should ERROR without explicit conversion)
    val c : i64 = 30
    val d : f64 = 4.5
    // val mixed_error = a + c               // Should ERROR: i32 + i64 requires explicit conversion
    // val mixed_error2 = a + d              // Should ERROR: i32 + f64 requires explicit conversion
    
    // Test 4C: Mixed with explicit conversions (should work)
    val mixed_explicit : i64 = a:i64 + c     // Should work: explicit i32 → i64
    val mixed_explicit2 : f64 = a:f64 + d    // Should work: explicit i32 → f64
    
    // ============ GAP 5: Division Operator Semantics ============
    // Documentation promises: / produces float, \ produces integer
    
    // Test 5A: Float division behavior
    val float_div1 = 10 / 3                  // Should be comptime_float
    val float_div2 : f64 = 22 / 7            // Should adapt to f64
    val float_div3 : f32 = 10 / 3            // Should adapt to f32
    
    // Test 5B: Integer division behavior  
    val int_div1 = 10 \ 3                    // Should be comptime_int
    val int_div2 : i64 = 22 \ 7              // Should adapt to i64
    val int_div3 : i32 = 100 \ 9             // Should adapt to i32
    
    // Test 5C: Division with concrete types
    val concrete_a : i32 = 20
    val concrete_b : i32 = 3
    val concrete_float_div : f64 = concrete_a:f64 / concrete_b:f64  // Should require explicit conversion
    val concrete_int_div : i32 = concrete_a \ concrete_b            // Should work: i32 \ i32 → i32
    
    // Test 5D: Division type consistency
    // val float_with_int_div = 10.5 \ 2.1   // Should ERROR: \ requires integer operands
    
    // ============ GAP 6: Comptime + Concrete Adaptation ============
    // Documentation promises: comptime types adapt to concrete context
    
    // Test 6A: Comptime adapts to concrete
    val concrete_base : i32 = 100
    val adapted_add : i32 = concrete_base + 42     // comptime_int should adapt to i32
    val adapted_mult : i32 = concrete_base * 3     // comptime_int should adapt to i32
    
    // Test 6B: Context determines result type
    val float_base : f64 = 3.14
    val adapted_float : f64 = float_base + 42      // comptime_int should adapt to f64
    val adapted_calc : f64 = float_base * 2.5      // comptime_float should adapt to f64
    
    // ============ GAP 7: Complex Expression Chains ============
    // Documentation promises: comptime operations chain without resolution
    
    // Test 7A: Chained comptime operations
    val step1 = 42 + 100                     // comptime_int
    val step2 = step1 * 2                    // comptime_int
    val step3 = step2 + 3.14                 // comptime_int + comptime_float → comptime_float
    val step4 = step3 / 2.0                  // comptime_float
    
    // Test 7B: Same chain, different resolutions
    val chain_f64 : f64 = step4              // Should adapt to f64
    val chain_f32 : f32 = step4              // SAME source → f32
    val chain_i32 : i32 = step4:i32          // Should require explicit conversion
    
    // ============ GAP 8: Boolean Operations ============
    // Documentation promises: comparison follows same rules as arithmetic
    
    // Test 8A: Comptime comparisons
    val comp1 = 42 > 30                      // comptime_int comparison → bool
    val comp2 = 3.14 >= 2.71                 // comptime_float comparison → bool
    val comp3 = 42 < 3.14                    // mixed comptime → bool
    
    // Test 8B: Mixed concrete comparisons (should require explicit conversion)
    val int_concrete : i32 = 10
    val float_concrete : f64 = 3.14
    // val comp_error = int_concrete < float_concrete  // Should ERROR: mixed concrete
    val comp_explicit = int_concrete:f64 < float_concrete  // Should work: explicit conversion
    
    // ============ GAP 9: Function Return Context ============
    // Documentation promises: return type provides comptime resolution context
    
    // Test 9A: Return type context
    val return_adapted = get_i32_value()     // Function should provide i32 context
    val return_flexible = get_comptime()     // Function should return comptime type
    
    // Test 9B: Function parameter context
    process_i64(42)                          // comptime_int should adapt to i64 parameter
    process_f32(3.14)                        // comptime_float should adapt to f32 parameter
}

// Helper functions for testing return/parameter context
func get_i32_value() : i32 = {
    return 42 + 100                          // Should resolve comptime_int to i32
}

func get_comptime() : i32 = {
    return 50 * 2                            // Should return i32 (context-driven)
}

func process_i64(value: i64) : void = {
    // Implementation not shown
}

func process_f32(value: f32) : void = {
    // Implementation not shown
}